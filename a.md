L**
URL（Uniform Resource Locator)统一资源定位器，用于定位互联网上的资源。常见的几种协议：http、https（安全加密协议）、ftp、file(本地文件）
当在浏览器中输入地址后，浏览器会智能匹配可能的URL，会从历史记录、标签等地方，找到可能对应的URL，然后给出智能提醒，让用户可以补全URL。
**第二步：域名解析（浏览器查找域名的IP地址）**
名词解释：
URL：http://www.baidu.com,其中baidu.com是域名；
DNS（Domain Name System,域名系统）：因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网。
域名解析（主机名解析）：通过主机名，最终得到该主机名对应的IP地址的过程。
DNS查询的两种方式：迭代查询和递归查询

1、递归查询：

![image](https://cloud.githubusercontent.com/assets/26688167/24867704/a7a988ac-1e40-11e7-9da3-db14976bbbc8.png)

当局部DNS服务器不能回答客户机的DNS查询时，由局部DNS服务器自己负责向其他DNS服务器进行查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。

2、迭代查询

![image](https://cloud.githubusercontent.com/assets/26688167/24868277/208b1fbe-1e42-11e7-9c67-1821de2d7a79.png)

当局部服务器自己不能回答客户机的DNS查询时，并不是由局部DNS服务器亲自向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端，客户端DNS程序继续向这些DNS服务器进行查询，直到查到结果为止。

域名解析流程：
step 1：请求一旦发起，浏览器首先解析这个域名，一般浏览器会缓存DNS记录一段时间，浏览器首先会查看浏览器缓存，看看其中有没有和这个域名相关的缓存，如果有就直接使用浏览器缓存里的IP。
step 2：如果在浏览器缓存中没有找到，浏览器会查看本地硬盘的hosts文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用hosts文件里面的IP地址。Windows系统下，hosts文件在c/etc/hosts目录下。127.0.0.1代表本机IP地址。
step 3：路由器缓存——一般路由器也会缓存域名信息。
step 4:ISP DNS缓存——如果在本地hosts文件中和路由器缓存中都没有找到对应的IP地址，浏览器就会发出一个DNS请求到本地DNS服务器（一般由网络接入服务商提供，如中国电信、中国移动等），本地DNS服务器会先查询它的缓存记录，如果缓存中有该条记录人，则直接返回结果；（递归查询） 
step 5：如果没有，本地服务器则向根域名服务器查找域名对应的IP地址。根域名服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以去域服务器上继续查询，并给出与服务器的地址。（迭代查询）

![image](https://cloud.githubusercontent.com/assets/26688167/24870125/dde53c48-1e47-11e7-9a3b-cf0c368ffae6.png)

DNS劫持：（又名域名服务器污染或域名服务器投毒）（DNS cache  pollusion )是指一些刻意制造出来的域名服务器封包，把域名指往不正确的IP地址。
DNS域名称空间的组织方式：

![image](https://cloud.githubusercontent.com/assets/26688167/24887630/b69eb8e2-1e8f-11e7-9311-fdd709ec1119.png)

DNS均衡负载：
当一个网站有足够多的用户时，假如每次的请求都定位到同一台机器上时，那这台机器随时可能会崩掉。处理的办法就是DNS均衡负载，原理是在DNS服务器中为同一个主机名分配多个IP地址，在应答DNS查询时，DNS服务器对每个查询将DNS文件中的主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。
![image](https://cloud.githubusercontent.com/assets/26688167/24887753/ef31e926-1e90-11e7-84c0-9a32461c0b62.png)

**第三步：服务器处理**
step 1：拿到域名对应的IP地址后，浏览器就会以一个随机端口（1024<端口<65535)向服务器的WEB程序（常用的Apache、Nginx、IIShttpd等）80端口发起TCP请求，服务器端的Web Server用于接收请求。这个连接请求到达服务器端后，进入网卡，然后进入TCP/IP协议栈（用于识别该连接请求，解封包，一层一层剥开），还有可能经过Netfiliter防火墙（属于内核模块）的过滤，最终到达WEB程序，最后建立TCP/IP的连接。
TCP连接如图所示：
![image](https://cloud.githubusercontent.com/assets/26688167/24887999/bf41216c-1e92-11e7-844b-f4aa53f295be.png)
step2：建立一个TCP连接后，发起一个http请求。一个典型的http request header 一般包括请求的方法（GET、POST、PUT、DELETER、HEAD、OPTION、以及TRACE).
相关知识点：
TCP三次握手；
TCP 四次挥手；

step3：服务器的永久重定向响应：服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“http://www.google.com"而非：http://googe.com".服务器重定向的原因：1、搜索引擎的排名有关，如果一个页面有两个地址（用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存中出现好几次），搜索引擎会以为他们是两个网站，结果造成每个搜索链接都减少而降低排名。而搜索引擎知道301重定向是什么意思，它就会把访问两个地址归到同一个网站。2、网站调整（如改变网页目录结构）；3、网页被移到一个新地址；4、网页扩展名改变（如应用需要把.php改成.html)
相关知识：
301和302的区别；

step 4：浏览器跟踪重定向地址，http请求发送到服务器，服务器处理请求：
    后端从固定端口接受TCP报文，就会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一
       步封装成HTTP  Request对象，供上层使用。

       反向代理：客户端可以直接通过http协议直接访问某网站服务器，网站管理员可以在中间加上一个Nginx,客户端请求Ngnix，Ngnix请求应用服务器，然后将结果返回给客户端。此时Ngnix就是反向代理服务器。
       ![image](https://cloud.githubusercontent.com/assets/26688167/24888559/ec684fae-1e96-11e7-821f-c185bacc289c.png)

       step 5：服务器收到请求，处理请求，返回一个HTTP响应。
       相关知识点：
       http响应和http请求文档

       **第四步：浏览器显示HTML**
       浏览没有安全接收html文档时，就已经开始显示页面。浏览器如何把页面呈现在屏幕上的呢？以Webkit的渲染过程为例：
       解析html以构建dom树——>构建render树——>布局render树——>绘制render树
       ![image](https://cloud.githubusercontent.com/assets/26688167/24888747/0824ea4e-1e98-11e7-8a28-8b33b06b9215.png)
       浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源，如link、script、image等，请求过程是异步的，并不会影响html文档加载。

       解析过程中，浏览器会先解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。

       相关知识点：
       reflow：DOM节点中的各个元素都是以盒模型的形式存在，这些需要浏览器去计算其位置和大小的过程
       repain:当盒模型的大小、位置以及其他属性确定下来后，浏览器便会绘制内容的过程。

       页面首次加载时会经历reflow和repain两个过程。这两个过程很消耗性能，尤其在移动设备上，会破坏用户体验，有时会造成卡顿。所以应尽量减少reflow和repain.

